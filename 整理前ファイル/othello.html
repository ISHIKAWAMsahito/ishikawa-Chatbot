<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>【API連携版】AI対戦オセロ</title>
  <style>
    body {
      background: #2c2c2c;
      color: #f0f0f0;
      font-family: 'Helvetica Neue', Arial, sans-serif;
      text-align: center;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding-top: 20px;
      gap: 30px;
      flex-wrap: wrap;
    }
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin-top: 0;
      margin-bottom: 10px;
      font-weight: 300;
      letter-spacing: 1px;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(8, 45px);
      grid-template-rows: repeat(8, 45px);
      gap: 3px;
      margin: 10px auto;
      width: max-content;
      background: #006400;
      border: 5px solid #1a1a1a;
      border-radius: 8px;
      padding: 5px;
      box-shadow: 0 10px 20px rgba(0,0,0,0.2);
    }
    .cell {
      width: 45px;
      height: 45px;
      background: #228B22;
      border-radius: 4px;
      position: relative;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    .cell.valid:hover {
      background: #32cd32;
      border: 2px solid white;
    }
    .stone {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 38px;
      height: 38px;
      border-radius: 50%;
      box-shadow: 0 3px 6px rgba(0,0,0,0.4);
      transition: all 0.3s ease;
    }
    .black {
      background: radial-gradient(circle at 30% 30%, #4d4d4d, #111);
    }
    .white {
      background: radial-gradient(circle at 70% 70%, #fff, #ccc);
    }
    #info {
      margin-top: 10px;
      font-size: 1.3em;
      min-height: 80px;
    }
    #reset {
      margin-top: 10px;
      padding: 10px 25px;
      font-size: 1em;
      background: #007bff;
      color: #fff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.2s;
    }
    #reset:hover {
      background: #0056b3;
    }
    .chat-container {
      width: 360px;
      display: flex;
      flex-direction: column;
    }
    #chat-log {
      height: 400px;
      overflow-y: auto;
      background: #3a3a3a;
      border: 1px solid #444;
      padding: 10px;
      text-align: left;
      border-radius: 5px;
      margin-bottom: 10px;
      font-size: 0.9em;
    }
    #chat-log p {
      margin: 0 0 8px 0;
      word-wrap: break-word;
      line-height: 1.4;
    }
    #chat-log p b { color: #87ceeb; }
    #chat-log p b.ai { color: #98fb98; }
    .thinking-bubble {
      display: inline-block;
      padding: 8px 12px;
      background: #555;
      border-radius: 15px;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>AI対戦オセロ</h1>
    <div id="board"></div>
    <div id="info"></div>
    <button id="reset">リセット</button>
  </div>

  <div class="chat-container">
    <h2>チャットログ</h2>
    <div id="chat-log"></div>
  </div>
  
  <script>
    const SIZE = 8;
    const EMPTY = 0, BLACK = 1, WHITE = 2;
    
    let board = [];
    let currentPlayer = BLACK;
    let gameEnded = false;
    
    const boardDiv = document.getElementById('board');
    const infoDiv = document.getElementById('info');
    const chatLog = document.getElementById('chat-log');

    const directions = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1],           [0, 1],
      [1, -1],  [1, 0],  [1, 1]
    ];
    
    function initBoard() {
      board = Array(SIZE).fill(0).map(() => Array(SIZE).fill(EMPTY));
      const mid = SIZE / 2;
      board[mid - 1][mid - 1] = WHITE;
      board[mid - 1][mid]     = BLACK;
      board[mid][mid - 1]     = BLACK;
      board[mid][mid]         = WHITE;
      gameEnded = false;
      currentPlayer = BLACK;
    }
    
    function isValidMove(x, y, player) {
      if (board[y][x] !== EMPTY) return false;
      for (const [dx, dy] of directions) {
        let nx = x + dx, ny = y + dy;
        if (nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE || board[ny][nx] !== (3 - player)) continue;
        while (true) {
          nx += dx; ny += dy;
          if (nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE || board[ny][nx] === EMPTY) break;
          if (board[ny][nx] === player) return true;
        }
      }
      return false;
    }

    function getValidMoves(player) {
        const moves = [];
        for (let y = 0; y < SIZE; y++) {
            for (let x = 0; x < SIZE; x++) {
                if (isValidMove(x, y, player)) {
                    moves.push([y, x]);
                }
            }
        }
        return moves;
    }

    function placeStone(x, y, player) {
      board[y][x] = player;
      for (const [dx, dy] of directions) {
        let stonesToFlip = [];
        let nx = x + dx, ny = y + dy;
        while (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE) {
          if (board[ny][nx] === EMPTY) break;
          if (board[ny][nx] === player) {
            for (const [fx, fy] of stonesToFlip) board[fy][fx] = player;
            break;
          }
          stonesToFlip.push([nx, ny]);
          nx += dx; ny += dy;
        }
      }
    }
    
    function drawBoard() {
      boardDiv.innerHTML = '';
      const validMoves = getValidMoves(currentPlayer);
      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.onclick = () => handleClick(x, y);
          if (board[y][x] !== EMPTY) {
            const stone = document.createElement('div');
            stone.className = 'stone ' + (board[y][x] === BLACK ? 'black' : 'white');
            cell.appendChild(stone);
          } else if (currentPlayer === BLACK && validMoves.some(m => m[0] === y && m[1] === x)) {
             cell.classList.add('valid');
          }
          boardDiv.appendChild(cell);
        }
      }
      updateInfo();
    }
    
    function updateInfo() {
      let blackCount = 0, whiteCount = 0;
      board.flat().forEach(s => {
        if (s === BLACK) blackCount++;
        else if (s === WHITE) whiteCount++;
      });
      if (gameEnded) {
        let result = '引き分けだにゃ！';
        if (blackCount > whiteCount) result = 'あなたの勝ちだにゃ！おめでとうにゃん！';
        else if (whiteCount > blackCount) result = 'AIの勝ちだにゃ！';
        infoDiv.innerHTML = `<b>ゲーム終了</b><br>黒 (あなた): ${blackCount} | 白 (AI): ${whiteCount}<br>${result}`;
      } else {
        let turn = currentPlayer === BLACK ? 'あなた (黒)' : 'AI (白)';
        infoDiv.innerHTML = `黒 (あなた): ${blackCount} | 白 (AI): ${whiteCount} <br>次の手番: <b>${turn}</b>`;
      }
    }
    
    function addChatMessage(sender, message, isThinking = false) {
      const msgElement = document.createElement('p');
      const senderClass = sender === 'AI' ? 'ai' : '';
      if (isThinking) {
        msgElement.innerHTML = `<b class="${senderClass}">${sender}:</b> <span class="thinking-bubble">${message}</span>`;
      } else {
        msgElement.innerHTML = `<b class="${senderClass}">${sender}:</b> ${message}`;
      }
      chatLog.appendChild(msgElement);
      chatLog.scrollTop = chatLog.scrollHeight;
      return msgElement;
    }

    function boardToText(board) {
        let boardText = "  A B C D E F G H\n";
        for (let r_idx = 0; r_idx < board.length; r_idx++) {
            boardText += `${r_idx + 1} `;
            for (const cell of board[r_idx]) {
                if (cell === EMPTY) boardText += ". ";
                else if (cell === BLACK) boardText += "B ";
                else boardText += "W ";
            }
            boardText += "\n";
        }
        return `あなたは 'W (白)' ですにゃ。相手は 'B (黒)' ですにゃ。\n\n${boardText}`;
    }

    async function handleAITurn() {
      if (gameEnded || currentPlayer !== WHITE) return;

      const validMoves = getValidMoves(currentPlayer);
      if (validMoves.length === 0) {
        switchPlayer();
        return;
      }
      
      const thinkingMsg = addChatMessage("AI", "考え中にゃ...", true);
      
      const boardText = boardToText(board);
      const validMovesStr = validMoves.map(m => `${String.fromCharCode(65 + m[1])}${m[0] + 1}`).join(", ");
      
      try {
        const response = await fetch(`/api/get_ai_move`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            board_text: boardText,
            valid_moves_str: validMovesStr
          })
        });

        thinkingMsg.remove();

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.detail || `サーバーエラー: ${response.status}`);
        }
        
        const data = await response.json();
        const content = data.response_text;
        
        const match = content.match(/MOVE:\s*([A-H][1-8])/i);
        let moveCoords;

        if (match) {
            const moveStr = match[1].toUpperCase();
            const col = moveStr.charCodeAt(0) - 65;
            const row = parseInt(moveStr.substring(1)) - 1;
            if (validMoves.some(m => m[0] === row && m[1] === col)) {
                moveCoords = { x: col, y: row };
            }
        }
        
        if (!moveCoords) { // AIが不正な手を選んだり、形式が違った場合
            const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
            moveCoords = { y: randomMove[0], x: randomMove[1] };
            addChatMessage("AI", "うーにゃ、良い手が思いつかないから、ここに置くにゃん！");
        } else {
            const reason = content.replace(/MOVE:\s*[A-H][1-8]/i, '').trim();
            addChatMessage("AI", reason || "ここに置くにゃん！");
        }

        placeStone(moveCoords.x, moveCoords.y, currentPlayer);
        switchPlayer();

      } catch (error) {
        console.error("AIの着手取得中にエラー:", error);
        thinkingMsg.remove();
        addChatMessage("AI", `ごめんにゃん、エラーが発生したにゃ。パスするにゃん。(詳細: ${error.message})`);
        switchPlayer();
      }
    }

    function switchPlayer() {
      currentPlayer = 3 - currentPlayer;
      const validMoves = getValidMoves(currentPlayer);
      if (validMoves.length === 0) {
        const skippedPlayer = currentPlayer === BLACK ? "あなた" : "AI";
        addChatMessage("システム", `${skippedPlayer} の置ける場所がないにゃん。パスするにゃ。`);
        currentPlayer = 3 - currentPlayer;
        if (getValidMoves(currentPlayer).length === 0) {
            gameEnded = true;
            addChatMessage("システム", "両者とも置ける場所がなくなったにゃん。ゲーム終了！");
        }
      }
      drawBoard();
      if (!gameEnded && currentPlayer === WHITE) {
        setTimeout(handleAITurn, 500);
      }
    }
    
    function handleClick(x, y) {
      if (gameEnded || currentPlayer !== BLACK) return;
      if (isValidMove(x, y, currentPlayer)) {
        const moveStr = String.fromCharCode(65 + x) + (y + 1);
        addChatMessage("あなた", `${moveStr} に置きます。`);
        placeStone(x, y, currentPlayer);
        switchPlayer();
      }
    }
    
    document.getElementById('reset').onclick = () => {
      initBoard();
      chatLog.innerHTML = '';
      addChatMessage("システム", "ゲーム開始だにゃん！ あなたは黒(B)だにゃ。どうぞにゃ！");
      drawBoard();
    };
    
    initBoard();
    addChatMessage("システム", "ゲーム開始だにゃん！ あなたは黒(B)だにゃ。どうぞにゃ！");
    drawBoard();
  </script>
</body>
</html>
